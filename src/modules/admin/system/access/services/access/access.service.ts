import { PageEnum } from '@src/enums';
import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
import { CreateAccessDto } from '../../controllers/access/dto/create.access.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { AccessEntity } from '../../entities/access.entity';
import { Repository, getConnection } from 'typeorm';
import { UpdateAccessDto } from '../../controllers/access/dto/update.access.dto';
import { AccessListVo, AccessVo } from '../../controllers/access/vo/access.vo';
import { RoleAccessEntity } from '../../../role/entities/role.access.entity';
import { AccessReqDto } from '../../controllers/access/dto/access.req.dto';

@Injectable()
export class AccessService {
  constructor(
    @InjectRepository(AccessEntity)
    private readonly accessRepository: Repository<AccessEntity>,
    @InjectRepository(RoleAccessEntity)
    private readonly roleAccessRepository: Repository<RoleAccessEntity>,
  ) {
  }

  /**
   * @param createAccessDto
   */
  async createAccess(createAccessDto: CreateAccessDto): Promise<string> {
    const { moduleName, actionName } = createAccessDto;
    if (moduleName) {
      const result: Pick<AccessEntity, 'id'> | undefined =
        await this.accessRepository.findOne({
          where: { moduleName },
          select: ['id'],
        });
      if (result) {
        throw new HttpException(
          `${moduleName}当前模块名已经存在,不能重复创建`,
          HttpStatus.OK
        );
      }
    }
    if (actionName) {
      const result: Pick<AccessEntity, 'id'> | undefined =
        await this.accessRepository.findOne({
          where: { actionName },
          select: ['id'],
        });
      if (result) {
        throw new HttpException(
          `${actionName}The current operation name already exists and cannot be created repeatedly`,
          HttpStatus.OK,
        );
      }
    }
    const access = this.accessRepository.create(createAccessDto);
    await this.accessRepository.save(access);
    return 'Created successfully';
  }

  /**
   * @param id
   */
  async destroyAccessById(id: number): Promise<string> {
    if (id <= 8) {
      throw new HttpException(
        'The resources generated by the system by default cannot be deleted',
        HttpStatus.OK,
      );
    }
    // 1.Determine whether there is a role associated with the current resource
    const roleAccessResult: Pick<RoleAccessEntity, 'id'> | undefined =
      await this.roleAccessRepository.findOne({
        where: { accessId: id },
        select: ['id'],
      });
    if (roleAccessResult) {
      throw new HttpException(
        'The current resource has been bound to the role and cannot be deleted directly',
        HttpStatus.OK,
      );
    }
    // 2.Check whether there are child nodes under the node
    const childNode: Pick<AccessEntity, 'id'> | undefined =
      await this.accessRepository.findOne({
        where: { parentId: id },
        select: ['id'],
      });
    if (childNode) {
      throw new HttpException(
        'The current node contains child nodes and cannot be deleted directly',
        HttpStatus.OK,
      );
    }
    const {
      raw: { affectedRows }
    } = await this.accessRepository.softDelete(id);
    if (affectedRows) {
      return 'Successfully deleted';
    } else {
      return 'failed to delete';
    }
  }

  /**
   * @Description: Modify the resource according to the resource id
   * @param {number} id
   * @param {UpdateAccessDto} updateAccessDto
   * @return {*}
   */
  async modifyAccessById(
    id: number,
    updateAccessDto: UpdateAccessDto
  ): Promise<string> {
    if (id <= 8) {
      throw new HttpException(
        'The resources generated by the system by default cannot be modified',
        HttpStatus.OK,
      );
    }
    const {
      raw: { affectedRows }
    } = await this.accessRepository.update(id, updateAccessDto);
    if (affectedRows) {
      return 'Successfully modified';
    } else {
      return 'Fail to edit';
    }
  }

  /**
   * @Description: Get all the menus to use when assigning roles
   * @return {*}
   */
  async accessList(): Promise<AccessVo[]> {
    return await this.accessRepository.find({
      where: [{ type: 1 }, { type: 2 }],
      select: ['id', 'moduleName', 'actionName', 'sort'],
    });
  }

  /**
   * @Description: Paging access to resources
   * @return {*}
   */
  async accessListPage(accessReqDto: AccessReqDto): Promise<AccessListVo> {
    const {
      pageSize = PageEnum.PAGE_SIZE,
      pageNumber = PageEnum.PAGE_NUMBER,
      parentId = 0
    } = accessReqDto;
    const [data, total] = await getConnection()
      .createQueryBuilder(AccessEntity, 'access')
      .where('access.parentId = :parentId', { parentId })
      .skip((pageNumber - 1) * pageSize)
      .take(pageSize)
      .orderBy({ 'access.sort': 'ASC', 'access.createdAt': 'DESC' })
      .printSql()
      .getManyAndCount();
    return {
      data,
      total,
      pageNumber,
      pageSize
    };
  }
}
