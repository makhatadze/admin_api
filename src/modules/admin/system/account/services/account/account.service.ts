import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { isMobilePhone, isEmail } from 'class-validator';
import { Repository, getConnection, ILike, Equal } from 'typeorm';

import { AccountEntity } from '../../entities/account.entity';
import { CreateAccountDto } from '../../controllers/account/dto/create.account.dto';
import adminConfig from '../../../../../../config/admin.config';
import { usernameReg } from '@src/constants';
import { UpdateAccountDto } from '../../controllers/account/dto/update.account.dto';
import { ModifyPasswordDto } from '../../controllers/account/dto/modify.password.dto';
import { ToolsService } from '@src/modules/shared/services/tools/tools.service';
import { AccountListVo, AccountVo } from '../../controllers/account/vo/account.vo';
import { AccountReqDto } from '../../controllers/account/dto/account.req.dto';
import { PageEnum, StatusEnum, PlatformEnum } from '../../../../../../enums';
import { AccountLastLoginEntity } from '../../entities/account.last.login.entity';
import { mapToObj } from '@src/utils';

@Injectable()
export class AccountService {
  constructor(
    @InjectRepository(AccountEntity)
    private readonly accountRepository: Repository<AccountEntity>,
    private readonly toolsService: ToolsService,
  ) {}

  /**
   * @Description: Create an account
   * @param {CreateAccountDto} createAccountDto
   * @return {*}
   */
  async createAccount(createAccountDto: CreateAccountDto): Promise<string> {
    const { username, email, mobile } = createAccountDto;
    const queryConditionList = [];
    if (username) {
      queryConditionList.push('account.username = :username');
    }
    if (email) {
      queryConditionList.push('account.email = :email');
    }
    if (mobile) {
      queryConditionList.push('account.mobile = :mobile');
    }
    const queryCondition = queryConditionList.join(' OR ');
    const findAccount: Pick<AccountEntity, 'username' | 'email' | 'mobile'> | undefined =
      await getConnection()
        .createQueryBuilder(AccountEntity, 'account')
        .select(['account.username', 'account.email', 'account.mobile'])
        .andWhere(queryCondition, { username, email, mobile })
        .getOne();
    if (findAccount) {
      const { username, email, mobile } = findAccount;
      if (usernameReg.test(username)) {
        return 'Creation failed, the username already exists';
      } else if (isMobilePhone(mobile, 'zh-CN')) {
        return 'Creation failed, the phone number already exists';
      } else if (isEmail(email)) {
        return 'Creation failed, the mailbox number already exists';
      } else {
        return 'Failed to create';
      }
    } else {
      const account: AccountEntity = this.accountRepository.create({
        ...createAccountDto,
        password: adminConfig.defaultPassword,
      });
      await this.accountRepository.save(account);
      return 'Created successfull';
    }
  }

  /**
   * @Description: Reset to default password based on user id
   * @return {*}
   */
  async resetPassword(id: number): Promise<string> {
    const {
      raw: { affectedRows },
    } = await this.accountRepository.update(id, {
      password: this.toolsService.makePassword(adminConfig.defaultPassword),
    });
    if (affectedRows) {
      return 'Reset successfully';
    } else {
      return 'Reset failed';
    }
  }

  /**
   * @Description: Delete account based on id
   * @param {number} id
   * @return {*}
   */
  async destroyById(id: number): Promise<string> {
    if (id === 1) {
      throw new HttpException(
        'The default account generated by the system cannot be deleted',
        HttpStatus.OK,
      );
    }
    const {
      raw: { affectedRows },
    } = await this.accountRepository.softDelete(id);
    if (affectedRows) {
      return 'Successfully deleted';
    } else {
      return 'Failed to delete';
    }
  }

  /**
   * @Description: Modify the password according to the account id
   * @param {number} id
   * @param {ModifyPasswordDto} modifyPasswordDto
   * @return {*}
   */
  async modifyPassWordById(id: number, modifyPasswordDto: ModifyPasswordDto): Promise<string> {
    if (id === 1) {
      throw new HttpException(
        'Passwords cannot be changed for accounts generated by the system by default',
        HttpStatus.OK,
      );
    }
    const { password, newPassword } = modifyPasswordDto;
    const findResult: Pick<AccountEntity, 'password'> | undefined = await getConnection()
      .createQueryBuilder(AccountEntity, 'account')
      .select([])
      .addSelect('account.password', 'password')
      .where('(account.id = :id)', { id })
      .getRawOne();
    if (findResult?.password && this.toolsService.checkPassword(password, findResult?.password)) {
      const {
        raw: { affectedRows },
      } = await this.accountRepository.update(id, {
        password: this.toolsService.makePassword(newPassword),
      });
      if (affectedRows) {
        return 'Successfully modified';
      } else {
        return 'Fail to edit';
      }
    } else {
      throw new HttpException(
        'The old password you entered is wrong or the account id you entered does not exist',
        HttpStatus.OK,
      );
    }
  }

  /**
   * @Description: Modify account information according to account id
   * @param {number} id
   * @param {UpdateAccountDto} updateAccountDto
   * @return {*}
   */
  async modifyById(id: number, updateAccountDto: UpdateAccountDto): Promise<string> {
    if (id === 1) {
      throw new HttpException(
        'The account generated by the system by default cannot be modified',
        HttpStatus.OK,
      );
    }
    const { username, email, mobile, status, platform } = updateAccountDto;
    const result: AccountEntity | undefined = await this.accountRepository.findOne(id);
    await this.accountRepository.save(
      Object.assign(result, { username, email, mobile, status, platform }),
    );
    return 'Successfully modified';
  }

  /**
   * @Description: Query account information based on account id
   * @param {number} id
   * @return {*}
   */
  async accountById(id: number): Promise<AccountVo | undefined> {
    return await this.accountRepository.findOne(id);
  }

  /**
   * @Description: Query account list based on conditions
   * @param {AccountReqDto} accountReqDto
   * @return {*}
   */
  async accountList(accountReqDto: AccountReqDto): Promise<AccountListVo> {
    const {
      pageNumber = PageEnum.PAGE_NUMBER,
      pageSize = PageEnum.PAGE_SIZE,
      email,
      username,
      mobile,
      status,
      platform,
    } = accountReqDto;
    const query = new Map();
    if (username) {
      query.set('username', ILike(username));
    }
    if (email) {
      query.set('email', Equal(email));
    }
    if (mobile) {
      query.set('mobile', Equal(mobile));
    }
    if ([StatusEnum.NORMAL, StatusEnum.FORBIDDEN].includes(Number(status))) {
      query.set('status', Equal(status));
    }
    if ([PlatformEnum.ADMIN_PLATFORM, PlatformEnum.MERCHANT_PLATFORM].includes(Number(platform))) {
      query.set('platform', Equal(platform));
    }
    const data: AccountVo[] = await getConnection()
      .createQueryBuilder(AccountEntity, 'account')
      .select('account.id', 'id')
      .addSelect('account.username', 'username')
      .addSelect('account.mobile', 'mobile')
      .addSelect('account.email', 'email')
      .addSelect('account.status', 'status')
      .addSelect('account.platform', 'platform')
      .addSelect('account.isSuper', 'isSuper')
      .addSelect('account.createdAt', 'createdAt')
      .addSelect('account.updatedAt', 'updatedAt')
      .addSelect(
        (qb) =>
          qb
            .select('lastLogin.lastLoginIp')
            .from(AccountLastLoginEntity, 'lastLogin')
            .where('(lastLogin.accountId = account.id)')
            .orderBy({ 'lastLogin.id': 'DESC' })
            .limit(1),
        'lastLoginIp',
      )
      .addSelect(
        (qb) =>
          qb
            .select('lastLogin.lastLoginAddress')
            .from(AccountLastLoginEntity, 'lastLogin')
            .where('(lastLogin.accountId = account.id)')
            .orderBy({ 'lastLogin.id': 'DESC' })
            .limit(1),
        'lastLoginAddress',
      )
      .addSelect(
        (qb) =>
          qb
            .select('lastLogin.lastLoginTime')
            .from(AccountLastLoginEntity, 'lastLogin')
            .where('(lastLogin.accountId = account.id)')
            .orderBy({ 'lastLogin.id': 'DESC' })
            .limit(1),
        'lastLoginTime',
      )
      .where(mapToObj(query))
      .skip((pageNumber - 1) * pageSize)
      .take(pageSize)
      .printSql()
      .getRawMany();
    const total: number = await getConnection()
      .createQueryBuilder(AccountEntity, 'account')
      .where(mapToObj(query))
      .getCount();
    // When the current mobile phone number or email address is illegal
    const formatData: AccountVo[] = data.map((item) => {
      const { username, mobile, email } = item;
      return {
        ...item,
        mobile: isMobilePhone(mobile, 'zh-CN') ? mobile : '',
        email: isEmail(email) ? email : '',
        username: usernameReg.test(<string>username) ? username : '',
      };
    });
    return {
      data: formatData,
      total,
      pageSize,
      pageNumber,
    };
  }
}
